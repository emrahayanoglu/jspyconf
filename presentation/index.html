<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Gercek Zamanlı Web Uygulamaları</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h2>Python ve Ruby ile Gercek Zamanlı Web Uygulamaları Gelistirmek</h2>
					<p>
						<small>Created by <a href="http://www.emrahayanoglu.com">Emrah Ayanoglu</a> / <a href="http://www.stm.com.tr">STM A.S</a></small>
					</p>
					<aside class="notes">
						Sunumunu baslat. Topic'ten bahset… Kendinden bahset… Genel olarak neler yaptigindan bahset…  STM'den bahset ve farkliliklardan bahset...
					</aside>
				</section>

				<section>
					<h2>Konular</h2>
					<ol>
						<li class="fragment">Gercek Zamanlı Web Uygulamaları</li>
						<li class="fragment">Ornek bir Startup - Olark</li>
						<li class="fragment">Genel Mimari</li>
						<li class="fragment">WebSocket ve web-socket-js</li>
						<li class="fragment">WebSocket Server</li>
						<li class="fragment">RabbitMQ ve Mesajlasma</li>
						<li class="fragment">XMPP Protokolu</li>
						<li class="fragment">Demo</li>
						<li class="fragment">Sorular</li>
					</ol>
					<aside class="notes">
						Bugun size anlatmak istedigim konulara soyle bakarsak sirasiyla diyerek basla… ve anlat… Demo olan bolumleri teker teker soyle… Ornek kodlar olacagini soyle...
					</aside>
				</section>

				<section>
					<h2>Gercek Zamanlı Web Uygulamaları</h2>
					<p>Server tarafından iletilen bilginin, en hızlı şekilde(low latency) client'lara aktarıldığı uygulamalardır.</p>
					<aside class="notes">
						Gercek zamanli web uygulamalarinin ne oldugunu anlat. Low latency'den bahset… ajax'dan farkini anlat
					</aside>
				</section>

				<section>
					<h2>Live Chat<h2>
					<img src="img/liveperson3.png">
					<aside class="notes">
						Simdi sirasiyla size ornekleri gostermek istiyorum… Ilk ornegimiz, herkesin tahmin edecegi gibi bir chat uygulamasi… live chat...
					</aside>
				</section>

				<section>
					<h2>Multiplayer Oyunlar<h2>
					<img src="img/zynga-poker.png">
					<aside class="notes">
						Tabiki multiplayer oyunlar.. her oyuncunun yapmis oldugu hareketlerin aninda diger oyunculara gitmesi gerekiyor...
					</aside>
				</section>

				<section>
					<h2>Finans<h2>
					<img src="img/finance.jpg">
					<aside class="notes">
						Borsa ve finans uygulamalari… Surekli degisen hisse senedi fiyatlari yine gercek zamanli uygulamalara ornek...
					</aside>
				</section>

				<section>
					<h2>Gercek Zamanlı Analitikler<h2>
					<img src="img/real-time-analytics.png">
					<aside class="notes">
						Son iki senedir populer olan gercek zamanli analitikler… Anlik olarak web sitesini ziyaret edenlerle ilgili istatistikler verir
					</aside>
				</section>

				<section>
					<h2>Ortak Çalısma Uygulamaları<h2>
					<img src="img/collaboration-tool.png">
					<aside class="notes">
						Ortak calisma alanlari (Collaboration) … mesela ornekteki gibi bir mockup tasarimi yapilirken hem beraber tasarlanmasi hemde mockup'in konusulmasi...
					</aside>
				</section>

				<section>
					<h2>Aktivite Akımları<h2>
					<img src="img/activity-stream.png">
					<aside class="notes">
						Aktivite akimlari… aslinda twitter ile gelen bir yapi. artik bircok yerde gorebiliyoruz… bu da tamamen gercek zamanli olarak calismakta...
					</aside>
				</section>

				<section>
					<h2>Ornek bir Startup</h2>
					<img src="img/logo-olark.png">
					<aside class="notes">
						Simdi size gercek zamanli bir web uygulamasini orneklemek icin benim begendigim bir startup'i anlatip onun tasarimini ve basitce kodlamasini yapmak istiyorum… Olark'i anlat…
					</aside>
				</section>

				<section>
					<h2>Olark</h2>
					<ul>
						<li class="fragment">2009 Ağustos ayında Y-Combinator desteğiyle kuruldu</li>
						<li class="fragment">Müşteri ile anlık Chat uygulamalarında bir yenilik gerçekleştirdi</li>
						<li class="fragment">Kolay entegre edilebilir, herhangi bir Jabber/XMPP Client sayesinde Müşteri ile konuşulabilir.</li>
						<li class="fragment">Ziyaretçinin gerekli her türlü bilgiye(lokasyon, web gezi bilgileri, v.b) Chat Client'tan ulaşılabilir.</li>	
					</ul>
					<aside class="notes">
						Olark'in ozelliklerini sirala… En onemli ozelligi olan web'den jabber client ile erisimini anlat… ayrica basit olarak web istatistiklerini de gosterdigini anlat...
					</aside>
				</section>

				<section>
					<h2>Olark</h2>
					<img src="img/buddy-list.png">
					<aside class="notes">
						Ornek resmi anlat… ve hangi detaylari gosterebildigini teker teker soyle… tabiki bu kullanmis oldugu teknolojilerle beraber oldugunu soyle...
					</aside>
				</section>

				<section>
					<h2>Genel Mimari</h2>
					<img src="img/arch1.png">
					<aside class="notes">
						Genel mimariyi detaylica anlat… oncelikle websocket'ten basla ardindan devam et… tabiki basit bir mimariden bahsettigimizi soyle…  burada herhangi bir gecici veya kalici bir veritabani bulunmadigindan bahset… Simdi size bu mimariyi teker teker anlatip olusturmaya calisacagini anlat.
					</aside>
				</section>

				<section>
					<h2>WebSocket</h2>
					<ul>
						<li class="fragment">HTML 5 ile gelen low-latency client-server haberleşmeyi sağlar</li>
						<li class="fragment">Ajax ve Ajax Long Polling'deki fazlalıkları atar</li>
					</ul>
					<aside class="notes">
						Oncelikle client tarafindan baslarsak websocket ile baslayacagini anlat… Websocket'in ozelliklerini teker teker anlat. Ozellikle Ajax ve Ajax Long Polling arasindaki farki anlat… Simdi birazda nasil kodlandigini anlat...
					</aside>
				</section>

				<section>
					<h2>WebSocket API</h2>
					<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;	
  var ws = new WebSocket(&quot;ws://example.com:10081/&quot;);
  ws.onopen = function() {
    ws.send(&quot;Hello&quot;);  // Mesaji gonder
  };
  ws.onmessage = function(e) {
    // Mesaj Geldi Olayi
    alert(e.data);
  };
  ws.onclose = function() {
     // Baglanti Kapandi Olayi
    alert(&quot;closed&quot;);
  };
&lt;/script&gt;</code></pre>
					<aside class="notes">
						Ilk ornegimiz bizim browser'imiz HTML 5 destekli ve WebSocket destekliyorsa, nasil calistirabilecegimizi ve kod detayini anlat...
					</aside>
				</section>

				<section>
					<h2>web-socket-js</h2>
					<ul>
						<li class="fragment">Alt yapı olarak Flash Socket'i ve ExternalInterface'i kullanır</li>
						<li class="fragment">HTML 5 destekli tarayıcı bulunmadığında iyi bir seçenektir</li>
						<li class="fragment">Tamamen WebSocket API benzeri bir API'a sahiptir</li>
					</ul>
					<aside class="notes">
						Ikinci olarak web-socket-js'i anlat. neden ihtiyac duydugumuzu soyle. browser desteklemesse web-socket-js tarafindan flash socket'i kullanarak ayni websocket api'yi kullanabilecegimizi anlat.
					</aside>
				</section>

				<section>
					<h2>web-socket-js</h2>
					<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;swfobject.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;web_socket.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  // WebSocketMain.swf'in yerini belirtiyoruz
  WEB_SOCKET_SWF_LOCATION = &quot;WebSocketMain.swf&quot;;
  // WebSocket API'la ayni API oldugundan aynen kullaniyoruz
  var ws = new WebSocket(&quot;ws://example.com:10081/&quot;);
  ws.onopen = function() {
    ws.send(&quot;Hello&quot;);  // Mesaji gonder
  };
  ws.onmessage = function(e) {
    // Mesaj Geldi Olayi
    alert(e.data);
  };
  ws.onclose = function() {
    alert(&quot;closed&quot;);
  };
&lt;/script&gt;</code></pre>
					<aside class="notes">
						Kod ornegini ve ozellikle api'in tamamen ayni oldugunu anlat...
					</aside>
				</section>				

				<section>
					<h2>WebSocket Server</h2>
					<p>Gercek Zamanlı Uygulamalar için Asenkron I/O bir WebSocket Server'a ihtiyacimiz var (Low-Latency)</p>
					<ul>
						<li class="fragment">Python
							<ul>
								<li class="fragment">Tornado</li>
								<li class="fragment">Twisted</li>
							</ul>
						</li>
						<li class="fragment">Ruby
							<ul>
								<li class="fragment">EventMachine</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Simdi ise artik client tarafini halletigimizi, artik bu web socketi karsilayabilecek bir websocket server'a ihtiyacimiz oldugunu anlat… burada neden asenkron i/o bir web server'a ihtiyacimiz oldugunu low latency ornegiyle beraber anlat… Daha sonra teker teker python ve ruby'deki kutuphaneleri sirala...
					</aside>
				</section>

				<section>
					<h2>Python - Tornado WebSocket Server</h2>
					<p>Friendfeed'in gucunu veren Web Server</p>
					<pre><code>import tornado.httpserver
import tornado.websocket
import tornado.ioloop
import tornado.web

class WSHandler(tornado.websocket.WebSocketHandler):
    def open(self):
        print 'yeni baglanti'
        self.write_message("Hello World")
      
    def on_message(self, message):
        print 'mesaj alindi %s' % message
 
    def on_close(self):
      print 'baglanti kapandi'

application = tornado.web.Application([
    (r'/ws', WSHandler),
])

if __name__ == "__main__":
    http_server = tornado.httpserver.HTTPServer(application)
    http_server.listen(8888)
    tornado.ioloop.IOLoop.instance().start()</code></pre>
    				<aside class="notes">
    					Oncelikle Python'dan basla… Python'da oldukca iyi bir Asenkron I/O calisan tornado web server'i anlat. Friendfeed'in gucunu aldigi bir web server'dir… Kodu anlat… teker teker iyice anlat...
					</aside>
				</section>

				<section>
					<h2>Ruby - EventMachine WebSocket Server</h2>
					<pre><code>require 'em-websocket'

EM.run {
  EM::WebSocket.run(:host => "0.0.0.0", :port => 8080) do |ws|
    ws.onopen { |handshake|
      puts "WebSocket connection open"
      # Mesaji client'lara yayinla
      ws.send "Merhaba Client, suraya #{handshake.path} baglandin"
    }
    ws.onclose { puts "Baglanti Kapandi" }

    ws.onmessage { |msg|
      puts "Mesaj Alindi: #{msg}"
      ws.send "Pong: #{msg}"
    }
  end
}</code></pre>
					<aside class="notes">
						Sonra ruby'den bahset… Ruby'deki eventmachine anlat… yine asenkron i'o calistigini soyle… sonra kodu anlat… cok benzer olduklarini soyle...
					</aside>
				</section>

				<section>
					<h2>Demo - WebSocket Server</h2>
					<aside class="notes">
						Simdi kodlari teker teker ac ve calistir… python ile websocket-js, ruby ile websocket dikkatli ol…
					</aside>
				</section>

				<section>
					<h2>RabbitMQ ve Mesajlasma</h2>
					<ul>
						<li class="fragment">Açık Kaynak Kodlu Mesaj Broker Yazılımıdır</li>
						<li class="fragment">AMQP(Advanced Message Queuing Protocol)'u uygular</li>
						<li class="fragment">Erlang diliyle yazılmıştır</li>
						<li class="fragment">Pub-Sub, Routing, Topics destekler</li>
						<li class="fragment">Kullananlar: BBC, NASA, Digg, SecondLife, Del.icio.us, Huffington Post</li>
					</ul>
					<aside class="notes">
						Simdi ise gelen mesajlarin kontrolu saglayan, bir mesaj kuyrugu yapisi olan rabbitmq 'yu anlat… detaylarini teker teker anlat… niye ihtiyac duydugumuzu soyle… kendi tecrubeni yani process queue olarak kullandigini ve cok memnun oldugunu soyle… butun ozelliklerini guzelce detaylandirarak anlat...
					</aside>
				</section>

				<section>
					<h2>RabbitMQ - Clients</h2>
					<ul>
						<li class="fragment">Python
							<ul>
								<li class="fragment">Pika</li>
							</ul>
						</li>
						<li class="fragment">Ruby
							<ul>
								<li class="fragment">AMQP</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Yine rabbitmq'ya erisebilmek icin uygun olan python ve ruby'deki kutuphaneler anlat kisaca… her ikiside asenkron calisabildigini soyle...
					</aside>
				</section>

				<section>
					<h2>Python - Pika Publisher</h2>
					<pre><code>#!/usr/bin/env python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters(
        host='localhost'))
channel = connection.channel()

channel.queue_declare(queue='jspyconftest')

channel.basic_publish(exchange='',
                      routing_key='jspyconftest',
                      body='Hello World!')
print " [x] Sent 'Hello World!'"
connection.close()</code></pre>
					<aside class="notes">
						Pika'nin publisher kismini anlatmaya basla… teker teker her bir satiri anlat… buradan mesajlarin gonderildigini ve kuyruga girdigini anlat...
					</aside>
				</section>	

				<section>
					<h2>Python - Pika Subscriber</h2>
					<pre><code>#!/usr/bin/env python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters(
        host='localhost'))
channel = connection.channel()
channel.queue_declare(queue='jspyconftest')
print ' [*] Mesajlar Bekleniyor. Cikmak icin CTRL+C'

def callback(ch, method, properties, body):
    print " [x] Received %r" % (body,)

channel.basic_consume(callback,
                      queue='jspyconftest',
                      no_ack=True)

channel.start_consuming()</code></pre>
					<aside class="notes">
						Pika'nin subscriber yani mesajalri kuyruk yapisindan alip isleyen yerlerdir… buradaki kod yapisini anlat… ozellikle callback kismini anlat...
					</aside>
				</section>

				<section>
					<h2>Ruby - AMQP Publisher & Subscriber</h2>
					<pre><code>require "amqp"
EventMachine.run do
  connection = AMQP.connect(:host => '127.0.0.1')
  puts "AMQP Broker a baglanildi."
 
  channel  = AMQP::Channel.new(connection)
  queue    = channel.queue("jspyconftest", :auto_delete => true)
  exchange = channel.direct("")
 
  queue.subscribe do |payload|
    puts "Mesaj Alindi: #{payload}. Disconnecting..."
    connection.close { EventMachine.stop }
  end
 
  exchange.publish "Hello, world!", :routing_key => queue.name
end</code></pre>
					<aside class="notes">
						Ruby'de bu islerin nasil olarak anlatildigini anlat… teker teker kodlari anlat...
					</aside>
				</section>	

				<section>
					<h2>Ruby AMQP - Birden - Çoka Aktarım</h2>
					<pre><code>require "amqp"
 
AMQP.start("amqp://dev.rabbitmq.com:5672") do |connection|
 channel  = AMQP::Channel.new(connection)
 exchange = channel.fanout("nba.scores")
 
 channel.queue("joe", :auto_delete => true).bind(exchange).subscribe do |payload|
    puts "#{payload} => joe"
 end
 
 channel.queue("aaron", :auto_delete => true).bind(exchange).subscribe do |payload|
    puts "#{payload} => aaron"
 end
 
 channel.queue("bob", :auto_delete => true).bind(exchange).subscribe do |payload|
    puts "#{payload} => bob"
 end
 
 exchange.publish("BOS 101, NYK 89").publish("ORL 85, ALT 88")
 
  # disconnect & exit after 2 seconds
 EventMachine.add_timer(2) do
    exchange.delete
 
    connection.close { EventMachine.stop }
 end
end</code></pre>
					<aside class="notes">
						Ikinci kodda ise bir tane mesaj yollandiginda bu mesaji uc farkli mesaj alici tarafindan alindigi bir ornegi goster… kodu anlat…
					</aside>
				</section>

				<section>
					<h2>Demo</h2>
					<aside class="notes">
						RabbitMQ'daki ornegi hem python da hem de kodda anlat… demoyu calistir… rabbitmq'nun vagrant'ta olusturulmus olan bir sanal makinede oldugunu soyle…
					</aside>
				</section>	

				<section>
					<h2>XMPP Protokolü</h2>
					<ul>
						<li class="fragment">XMPP(Extendable Messaging and Presence Protocol) XML mesaj tabanlı uygulamalar için haberleşme protokolüdür</li>
						<li class="fragment">Jabber adıyla da bilinir. (Gtalk, Facebook Chat, Gabber, v.b)</li>
						<li class="fragment">Genişletilebilir olmasından dolayı VoIP, Video, File Transferi, Multiplayer Oyun gibi alanlarda oldukça kullanışlıdır</li>
						<li class="fragment">Protokolün detayları için: <a href="http://www.xmpp.org">XMPP Foundation</a></li>
					</ul>
					<aside class="notes">
						Artik mimarinin son bolumu olan XMPP kismini anlat… xmpp protikolunu anlat… burada xmpp'yi kullanmanin tek amacinin jabber client'a yani gtalk gibi bir client mesaj yollamak odlugunu anlat… teker teker ozelliklerini soyle… aslinda rabbitmq gibi bir mesaj kuyrugu yapisina da sahip oldugunu soyle… orneklerini anlat...
					</aside>
				</section>

				<section>
					<h2>XMPP - Mimari</h2>
					<img src="img/xmpp-wikibooks.png">
					<aside class="notes">
						genel mimariden bahset… merkezi olmadigini, tamamen lokal merkezlerin olustugu ve birbirleriyle haberlesildigini bir ornek ile anlat… ahmet@jabber.org ile mehmet@gmail.com nasil haberlestigini anlat...
					</aside>
				</section>

				<section>
					<h2>XMPP - Clients</h2>
					<ul>
						<li class="fragment">Python
							<ul>
								<li class="fragment">SleekXMPP</li>
							</ul>
						</li>
						<li class="fragment">Ruby
							<ul>
								<li class="fragment">XMPP4R</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						xmpp'yi kullanabilmemizi saglayan client'lari anlat… iste python da bu ruby de su var fln de...
					</aside>
				</section>

				<section>
					<h2>Python - SleekXMPP</h2>
					<pre><code>import sys
import sleekxmpp
def main(): 
  bot = EchoBot("jspyconftest@ufuks-macbook-pro.local", "12345")
  bot.run() 

class EchoBot: 
  def __init__(self, jid, password) : 
    self.xmpp = sleekxmpp.ClientXMPP(jid, password) 
    self.xmpp.add_event_handler("session_start", self.handleXMPPConnected) 
    self.xmpp.add_event_handler("message", self.handleIncomingMessage) 

  def run(self):
    self.xmpp.connect() 
    self.xmpp.process(threaded=False) 

  def handleXMPPConnected(self, event):
    print "Baglandi" 
    self.xmpp.sendPresence(pstatus = "Send me a message")
    self.xmpp.sendMessage("jspyconftest@ufuks-macbook-pro.local","Hello World")

  def handleIncomingMessage(self, message): 
    self.xmpp.sendMessage(message["from"], message["body"]) 

if __name__ == "__main__" :
    main()</code></pre>
					<aside class="notes">
						sonra python kismini anlat…  kodlari ayrintili bir sekilde anlat...
					</aside>
				</section>

				<section>
					<h2>Ruby - XMPP4R</h2>
					<pre><code>require 'rubygems'
require 'xmpp4r/client'
# Hash yardimiyla ufak bir sozluk olusturuyoruz
hash = {}
hash['ruby'] = 'Greatest little object oriented scripting language'
hash['xmpp4r'] = 'Simple XMPP library for ruby'
hash['xmpp'] = 'Extensible Messaging and Presence Protocol'

# XMPP Server baglan ve kullanici adi ve sifreyi dogrula
jid = Jabber::JID::new('jspyconftest@ufuks-macbook-pro.local')
cl = Jabber::Client::new(jid)
cl.connect
cl.auth('12345')

# Baglandigini ve online oldugunu bildir
cl.send Jabber::Presence::new

# Belirtilen Client'a mesaj yolla
salutation = Jabber::Message::new( 'jspyconftest@ufuks-macbook-pro.local', 'DictBot ready' )
salutation.set_type(:chat).set_id('1')
cl.send salutation 

# Mesaj callback olusturarak gelen mesajlari kontrol et
cl.add_message_callback do |inmsg|
    resp = hash[inmsg.body]
    if resp == nil
      resp = "don't know about " + inmsg.body
    end

    # Cevabini yolla
    outmsg = Jabber::Message::new( inmsg.from, resp )
    outmsg.set_type(:chat).set_id('1')
    cl.send outmsg
end
while 1
end</code></pre>	
					<aside class="notes">
						ruby kismini anlat...
					</aside>
				</section>				

				<section>
					<h2>Olark Clone Demo</h2>
					<aside class="notes">
						ve son olarak artik olark'a benzer basit bir yapiyi anlat… yani web'den jabber client'a nasil aktarildigini anlat… ve ruby'de yazildigini python'a zaman kalmadigini ancak devam edip onunda tamamlanacagini ve demoyu anlat…  github'dan takip edebilirsiniz de...
					</aside>
				</section>

				<section>
					<h2>Sonuç</h2>
					<ul>
						<li class="fragment">Gerçek Zamanlı Web Uygulamaları Artık Her Yerde!</li>
						<li class="fragment">WebSocket Server: Python Tornado, Ruby EventMachine</li>
						<li class="fragment">Message Queue: RabbitMQ, Python Pika, Ruby AMQP</li>
						<li class="fragment">XMPP Protokolü: Python SleekXMPP, Ruby XMPP4R</li>
					</ul>
					<aside class="notes">
						sonucu anlat… teker teker ozetle...
					</aside>
				</section>

				<section>
					<h1>Sorular!</h1>
					<aside class="notes">
						varsa sorusu olanlari duymaktan memnuniyet duyacagini soyle...
					</aside>
				</section>

				<section>
					<h1>Tesekkürler :)</h1>
					<h2>THE END</h2>
					<h3>BY Emrah Ayanoglu</h3>
					<p>Twitter: <a href="https://twitter.com/emrahayanoglu">@emrahayanoglu</a></p>
					<p>Github: <a href="https://github.com/emrahayanoglu">emrahayanoglu</a></p>
					<aside class="notes">
						boyle iyi bir izleyiciye konusmanin bir zevk oldugunu soyle… beni dinlediginiz icin tesekkur et…
					</aside>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: 'sky', // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
